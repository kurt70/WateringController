# Codex Instructions – Watering Controller

## Goal
Implement a watering system with safety and reliability as first priority.

- Two ESP32 devices:
  1. Pump controller
  2. Water level controller (4 induction sensors)
- Communication via MQTT (Eclipse Mosquitto)
- Backend is the scheduling and safety authority
- Web UI allows remote configuration and live monitoring

## General Rules
- You do not need to ask permission to read or modify markdown files or code under the workspace root, to list directories/files, to traverse the directory structure from the workspace root when locations are unclear, or to run tools/commands scoped to the workspace root (including process checks like `Get-Process`). Do not ask for permission before reading file contents under the workspace root.
- Do not ask for permission before running PowerShell commands related to reading, editing, building, or testing within the workspace root.
- Prefer minimal diffs.
- Do not refactor or rename without explicit instruction.
- Do not change public contracts (MQTT, API, DB schema) without updating docs.
- When unsure, ask or add TODO comments instead of guessing.

## Repo Structure
- `src/backend/` – ASP.NET Core backend
- `src/frontend/` – Web UI
- `firmware/pump-esp32/`
- `firmware/level-esp32/`
- `docs/` – Architecture and contracts

Maintain strict separation of concerns between layers.

## Safety Rules (Non-Negotiable)
- The pump MUST NOT run if water level is below threshold.
- If water level is unknown or stale, default to "do not run".
- Backend is the authoritative policy engine.
- ESP32 firmware must implement local failsafes (watchdog, max runtime).

## Backend Stack
- Target framework: **.NET 10 LTS**
- ASP.NET Core with minimal APIs
- Dependency Injection + options pattern
- Scheduling via BackgroundService
- MQTT via MQTTnet
- Persistence: SQLite by default (EF Core or simple repository)

### Backend Responsibilities
- Maintain watering schedules
- Evaluate safety rules before issuing pump commands
- Cache latest MQTT state from devices
- Publish system alarms and state updates
- Push realtime updates to frontend via SignalR

## MQTT Contract
- Use JSON payloads (UTF-8)
- Keep payloads backward compatible when possible
- Retained messages ONLY for state topics
- Commands should include correlation/request id

### Topic Pattern
- `<config_prefix>/WateringController/pump/cmd`
- `<config_prefix>/WateringController/pump/state`
- `<config_prefix>/WateringController/waterlevel/state`
- `<config_prefix>/WateringController/system/state`
- `<config_prefix>/WateringController/system/alarm`

Do not rename topics without updating `docs/mqtt.md`.

## Frontend
- Use existing frontend technology in repo
- Default preference: Blazor WebAssembly
- Use SignalR for live updates
- Focus on clarity and safety feedback (level, pump status, alarms)

## Testing
- Add unit tests for:
  - scheduling logic
  - safety rules ("no pump when empty")
- Prefer deterministic tests over time-based flakiness

## Logging
- Structured logs for:
  - MQTT messages (topic + summary)
  - pump run decisions (allowed/denied + reason)
  - alarms and failures
- Never log secrets or credentials

## Documentation Updates
Any change to behavior or contracts must update:
- `docs/mqtt.md`
- `docs/architecture.md`
- `README.md` (if setup or usage changes)
- Any documentation, both in code or other places, must be in english

## Output Expectations
- Brief explanation of intent and decisions
- List of changed files
- Note any manual steps required

## Testing Workflow
- When testing code changes, stop the backend process, rebuild the solution, then start the backend again.
- If builds fail due to locked frontend files, stop MSBuild/VS build-host processes and retry the build.
- When the user requests a new test run, proceed without asking for approval until the API is running again.

